# GUID feature

## Description

A set of api endpoints will be made available under the /user api. These will allow
the generation and lookup of random strings representing a user identifier. Generation and
lookup of these identifiers is transparent to the user.

Scopes that give access to this functionality:

  - `user:admin` (Since we won't expose this in the UI for now I don't think this is required?)
  - `user:info` (anyone with an authorization for that user can request identifiers)

These identifiers can not be deleted: if an authorization is dropped but later reacquired,
it feels like expected behavior that old identifiers can still be recovered. This also
requires the ability to look them up in the database again.

## Identifier format

33 Random generated bytes, base64 encoded. This encoding should use the `urlencoding`
standard to ensure that there are no random `/` characters (important as we can use
these identifiers in urls). 33 bytes instead of 32 so there is no padding added by the
base64 encoding.

## Storage format

Info is stored in the database in a separate collection with the following fields
(naming subject to change):

  - `username`: The username of the person this identifier will representing
  - `grantedTo`: The username or globalid of the party requesting this identifier.
    Only this party can use this identifier.
  - `identifier`: The generated random identifier for the user

## Endpoints

1. `GET /users/{username}/generateidentifier`
  - Generate a new identifier.
  - Use the client_id from the request as set by the middleware as the grantedTo party
  - Save the user identifier in the db and return only this id in the response body
  - There is a limit to the max amount of identifiers a user-azp relation can have

2. `GET /users/{username}/listidentifiers`
  - List all generated identifiers for this party
  - Does not generate a new identifier itself

3. `GET /users/identifier/lookup?id={identifier}`
  - Lookup the username behind an identifier;
  - Only if the client_id from the request matches the one saved in the db
  - If the id is not found, also return a `403` (this party is not authorized to look up this identifier)
  - Return username as json in response body

## Possbile issues:

- Handling authorization in the middleware:

  Currently the first middleware convers a user identifier to the username. This is then
  passed to the scopes middleware to handle authorization. Only then the underlying authorization
  from the request is checked. But this is actually already needed to verify that this
  party can use the identifier. 3 solutions come to mind:

  - Duplicate some of the logic checking the authorization to the identification middleware
  - Add some values to the request when passing it from the first to the second middleware
    The second middleware needs to then check these values. This means we build in some dependency
    in the middlewares, they are no longer cleanly separated.
  - Handle the authorization check in the API endpoint. The identifier is already
    converted to a username, so some extra values need to be added to the request.

  None of the 3 presented options are perfect, so we will need to investigate how
  to handle this in the cleanest way possible

- Client credentials jwt for users:

  The authorized party in said jwts is a random string, as it is the clientid from the
  user api key (as said this is randomly generated, unlike the clientid of an organization).
  If we use this authorized party in all cases (as we should), users will be able to
  request identifiers for themselves via the api (again, as they should), but this
  identifier will be linked to the user api key instead of the user. As a result:

  - Users with multiple api keys will need to remember which exact key the used
    if they want to verify that an identifier is indeed linked to them
  - If they delete the api key, they will forever loose the ability to verify this,
    as it is linked to the apikey.

  A possible solution for this would be to check if the authorization is provided by a
  user client credentials jwt, and in this case take the username from the jwt. But this
  feels like building in code dependency and loss of separation again.

## Further remarks:

- Find a good limit to the amount of generated identifiers:
  Although a limit should be installed to prevent malicious parties from filling the
  database with identifiers, most blockchain related services will require a large amount
  of identifiers to maintain full transparency and avoid all data mining.

# GUID feature

## Description

A set of api endpoints will be made available under the /user api. These will allow
the generation and lookup of random strings representing a user identifier. Generation and
lookup of these identifiers is transparent to the user.

Scopes that give access to this functionality:

  - `user:admin` (Since we won't expose this in the UI for now I don't think this is required?)
  - `user:info` (anyone with an authorization for that user can request identifiers)

These identifiers can not be deleted: if an authorization is dropped but later reacquired,
it feels like expected behavior that old identifiers can still be recovered. This also
requires the ability to look them up in the database again.

These new identifiers should be able to be used as user identifiers in api calls.

## Identifier format

33 Random generated bytes, base64 encoded. This encoding should use the `urlencoding`
standard to ensure that there are no random `/` characters (important as we can use
these identifiers in urls). 33 bytes instead of 32 so there is no padding added by the
base64 encoding.

## Storage format

Info is stored in the database in a separate collection with the following fields
(naming subject to change):

  - `username`: The username of the person this identifier will representing
  - `grantedTo`: The username or globalid of the party requesting this identifier.
    Only this party can use this identifier.
  - `identifier`: The generated random identifier for the user

## Endpoints

1. `GET /users/{username}/generateidentifier`
  - Generate a new identifier.
  - Use the client_id from the request as set by the middleware as the grantedTo party
  - Save the user identifier in the db and return only this id in the response body
  - There is a limit to the max amount of identifiers a user-azp relation can have

2. `GET /users/{username}/listidentifiers`
  - List all generated identifiers for this party
  - Does not generate a new identifier itself

3. `GET /users/identifier/lookup?id={identifier}`
  - Lookup the username behind an identifier;
  - Only if the client_id from the request matches the one saved in the db
  - If the id is not found, also return a `403` (this party is not authorized to look up this identifier)
  - Return username as json in response body

## Additional work

Because the user identifier middlewares need to be aware of the `client_id` to correctly
authorize or block calls with a `GUID` as identifier. To enable this, the current
implementation of setting the `client_id` in the authorization middleware will be removed,
and implemented in a separate middleware at the beginning of the middleware chain.
The useridentifier middlware can then use this `client_id` should it be required.
Also the functionality of the useridentifier middleware should be put in a separate function
so that it can be reused by the endpoints which expect a json format.

## Possbile issues:

- Client credentials jwt for users:

  The authorized party in said jwts is a random string, as it is the clientid from the
  user api key (as said this is randomly generated, unlike the clientid of an organization).
  If we use this authorized party in all cases (as we should), users will be able to
  request identifiers for themselves via the api (again, as they should), but this
  identifier will be linked to the user api key instead of the user. As a result:

  - Users with multiple api keys will need to remember which exact key the used
    if they want to verify that an identifier is indeed linked to them
  - If they delete the api key, they will forever loose the ability to verify this,
    as it is linked to the apikey.

  A possible solution for this would be to check if the authorization is provided by a
  user client credentials jwt or access token, and in this case take the username from the jwt. But this
  feels like building in code dependency and loss of separation again.

## Further remarks:

- Find a good limit to the amount of generated identifiers:
  Although a limit should be installed to prevent malicious parties from filling the
  database with identifiers, most blockchain related services will require a large amount
  of identifiers to maintain full transparency and avoid all data mining.
